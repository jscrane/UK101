.DATA $9000 ... $9048
.DATA $923C ... $9249
.DATA $9254 ... $9287
.DATA $97E9 ... $97FF

; this rom
TMPLO   = $F0    ; temp pointer / integer low byte
TMPHI   = $F1    ; temp pointer / integer high byte
TMP2LO  = $F2    ; secondary temp low (often compare/base)
TMP2HI  = $F3    ; secondary temp high
FMTBEG = $57     ; start of format/channel spec
FMTDOT = $58     ; dot modifier position
FMTEND = $59     ; end of format/channel spec
EXTCMDS = $9000  ; extension command name table
CMD_SCR  = $9000   ; &SCR
CMD_SET  = $9004   ; &SET
CMD_TEST = $9008   ; &TEST
CMD_VLIN = $900D   ; &VLIN
CMD_HLIN = $9012   ; &HLIN
CMD_BLK  = $9017   ; &BLK
CMD_GO   = $9023   ; &GO (and &GO$)
CMD_GET  = $901F   ; &GET
CMD_GS   = $9045   ; &GS
CMD_GT   = $9042   ; &GT
CMD_RD   = $903F   ; &RD
CMD_INAT = $9037   ; &INAT
CMD_PUTA = $9031   ; &PUTAT
CMD_PRUS = $9026   ; &PRINTUSNG
CMD_QUOT = $901E   ; &" (quote command)
CMD_WI   = $903C   ; &WI (and &WI$)
CMD_CWI  = $901B   ; &CWI (and &CWI$)

RDHEX4  = $9049  ; read 4 hex digits into EXECPTR
HEXIN   = $905E  ; convert ASCII hex digit into EXECPTR
CMDINIT = $907E  ; initialise command buffer and limits
BASSTK = $90AF   ; rebuild BASIC stack frame for extension commands
GETADDR2 = $90D4 ; comma + line check + address parse
ADDRREPL = $90E6 ; unwind + reparse address
LINCMP  = $90F1  ; compare EXECPTR with target line (F2/F3)
CMDCHAR = $9162  ; process command character with bounds checking

CMDJUMPT = $9182   ; extended command jump table
SCRCMD   = $9308   ; &SCR handler
SETCMD   = $9346   ; &SET row,column,char
TESTCMD  = $937F   ; &TEST handler
VLINCMD  = $93BF   ; &VLIN handler
HLINCMD  = $9411   ; &HLIN handler
BLKCMD   = $9479   ; &BLK handler
GOCMD    = $94B0   ; &GO / &GO$ handler
GETCMD   = $9497   ; &GET handler
GSCMD    = $96E4   ; &GS handler
GTCMD    = $9724   ; &GT handler
RDCMD    = $97A1   ; &RD handler
INATCMD  = $90E6   ; &INAT handler
PUTATCMD = $90AF   ; &PUTAT handler
PRTUSCMD = $AE88   ; &PRINTUSNG handler
CMDEXIT  = $91BA   ; shared extended-command exit

BASIC5 = $9200
READYMSG = $9288 ; prints "OK\r\nReady\r\n"
EXTNEXT = $92E1  ; fetch next keyword byte from EXTCMDS
OKREADY = $97E9  ; OK / Ready message string
EXTDISP = $929B  ; '&' extension statement dispatcher
EXTSCAN = $92DF  ; scan extension command table at $9000
EXTCHAR = $92ED  ; return current extension char (mask bit 7)
CMDSTORE = $931D ; store command character into indexed buffer
CMDCOPY = $93A8  ; copy command characters via CMDSTORE
KEYSCAN = $9431  ; keyboard scan and decode
INDJMP  = $9482  ; indirect JMP via EXECPTR
GETADDR = $9485  ; parse hex address or comma
PRINBUF = $9510  ; print input buffer then redisplay statement
EXECADDR = $9523 ; execute inline address operand
SCANMARK = $9581 ; scan input for > # .# markers
CMDOUT = $96C8   ; output command char and advance column
KEYWAIT = $9750   ; wait for valid keypress (with filtering)
LINSTEP = $97CC  ; validate & step line delta

; cegmon
GETKEY = $FD00   ; wait till key pressed, return with ASCII value in A register
KEYWRT = $FCBE   ; write-to-keyboard
KEY2XR = $FCC6   ; read-X-from keyboard
OUTVEC = $FFEE   ; output vector

; BASIC
BASICV = $0000   ; BASIC cold/warm entry JMP vector (patched to $9200)
READYV = $0003   ; print OK / Ready → $9288
CHRGOTV = $00C2  ; character re-entry (no TXTPTR advance): JMP into BASIC text stream
TXTPTR = $00C3   ; low byte of JMP target / BASIC text pointer
TXTPTRH = $00C4  ; high byte of JMP target / BASIC text pointer
STMTV = $00C5    ; extension statement dispatcher JMP vector (patched to $929B)
STMTCTV  = $00C9 ; resume statement execution
KEYDSPV  = $00D3 ; keyword dispatcher vector
NEWSTMTV = $0134 ; statement restart vector
LINESIZE = $013C ; record size used to move from one stored line to the next

EXECPTRL = $11   ; execution address vector (low)
EXECPTRH = $12   ;
INBUFL = $13     ; BASIC input line buffer (low)
INBUFH = $14     ; BASIC input line buffer (high)
CMDEXEC = $00BC  ; statement executor (RTS trampoline)

EVALSTK = $A212  ; evaluate expression with forced BASIC stack context
PREPWMST = $A274 ; abort execution, return to READY
BASCONT = $A5C2  ; BASIC statement continuation
WARMSTRT = $A491 ; warm start
GETADR = $A6BC   ; locate variable and return its address/descriptors
SYNCHR = $A70C   ; require specific character in A, else syntax error
CHRPUT = $A74F   ; return current char (no advance) / pushback last char
GETBYT = $A7CD   ; parse byte value (0–255), syntax/error checked
PRNTCRLF = $A8E5 ; end-of-PRINT, newline handler
STMTDISP = $A86C ; statement dispatcher
PRINT = $A8C3    ; PRINT statement handler
PTRGET = $A94F   ; parse variable name and return pointer to its descriptor
CHKCOM = $AAAD   ; syntax check: require comma, else SYNTAX ERROR
CHKNUM = $AAC1   ; verify expression result is numeric, error if string
NEWSTMT = $AC01  ; statement restart / main execution dispatcher
EVAL = $AC0C     ; expression evaluation
FRMEVL = $AD0B   ; evaluate expression (numeric or string)
FRMEVL1 = $AE88  ; expression evaluator continuation / operator-precedence loop
INT2FAC = $AFC1  ; convert integer in A:Y to FAC
CHRIN = $B0AE    ; get next input character into A
CRLF = $B2B6     ; output carriage return + line feed
CHROUT = $B3AE   ; output character in A to current output device
ERRDISP = $B408  ; display BASIC error and return to READY
INPUT = $B96E    ; INPUT statement handler
