.DATA $9000 ... $91FF
.DATA $9254 ... $92A0
.DATA $97E9 ... $97FF

; main entry point
BASIC5 = $9200

; cegmon
GETKEY = $FD00   ; wait till key pressed, return with ASCII value in A register
KEYWRT = $FCBE   ; write-to-keyboard
KEY2XR = $FCC6   ; read-X-from keyboard

; BASIC
CURLINL = $11    ; current BASIC line number (low)
CURLINH = $12    ; current BASIC line number (high)
INBUFL = $13     ; BASIC input line buffer (low)
INBUFH = $14     ; BASIC input line buffer (high)
CMDEXEC = $00BC  ; statement executor (RTS trampoline)
TXTPTR  = $C3    ; BASIC text pointer (low)
TXTPTRH = $C4    ; BASIC text pointer (high)
PREPWMST = $A274 ; abort execution, return to READY
WARMSTRT = $A491 ; warm start
GETADR = $A6BC   ; locate variable and return its address/descriptors
SYNCHR = $A70C   ; require specific character in A, else syntax error
CHRPUT = $A74F   ; return current char (no advance) / pushback last char
GETBYT = $A7CD   ; parse byte value (0â€“255), syntax/error checked
PRNTCRLF = $A8E5 ; end-of-PRINT, newline handler
STMTDISP = $A86C ; statement dispatcher
PRINT = $A8C3    ; PRINT statement handler
PTRGET = $A94F   ; parse variable name and return pointer to its descriptor
CHKCOM = $AAAD   ; syntax check: require comma, else SYNTAX ERROR
CHKNUM = $AAC1   ; verify expression result is numeric, error if string
NEWSTMT = $AC01  ; statement restart / main execution dispatcher
EVAL = $AC0C     ; expression evaluation
FRMEVL = $AD0B   ; evaluate expression (numeric or string)
FRMEVL1 = $AE88  ; expression evaluator continuation / operator-precedence loop
CHRIN = $B0AE    ; get next input character into A
CRLF = $B2B6     ; output carriage return + line feed
CHROUT = $B3AE   ; output character in A to current output device
ERRDISP = $B408  ; display BASIC error and return to READY
INPUT = $B96E    ; INPUT statement handler
