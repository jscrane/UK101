.DATA $8027 ... $804D
.DATA $806E ... $807B
.DATA $8159 ... $819D
.DATA $81C1 ... $81E2
.DATA $864B ... $868B
.DATA $8754 ... $8759
.DATA $87FC ... $87FF
.DATA $8A7E ... $8A96
.DATA $8E9F ... $8FFF

; cegmon
NEWMON = $FE00   ; reset entry to machine code monitor
OUTPUT = $FF9B   ; general output routine, to screen and ACIA
MENTRY = $FE0C   ; non-reset entry to monitor: clear screen, zero 'current address'
MSTART = $F97E   ; entry to command/address mode
OUTVEC = $FFEE   ; normally points to OUTPUT
GETCHR = $FEE9   ; get char from keyboard or ACIA
SETLOD = $FE70   ; sets BASIC load flag, clears save flag
BUMP = $FEF9     ; increment 'current address' at (FE)
ROLSTR = $FEDA   ; roll new nibble into (FE) if X=2, or into FC if X=0
ASCHEX = $FE93   ; strip ASCII digit to hex; set to 0x80 if not hex
CRLF = $FBF5     ; print CR/LF to display
SPCOUT = $FBE6   ; print ASCII space to display
PRDATD = $FEBD   ; print data byte in FC to display
QDDATD = $FEB6   ; print address in (FE) to display

; basic
ENDSTMT = $A265  ; finish BASIC statement, continue execution
PREPWMST = $A274 ; abort execution, return to READY
NEXTSTMT = $A27D ; statement finished, maybe more on this line
ERROR = $A280    ; general error
NEXTLINE = $A29D ; line finished, go to next line
FRMNUM = $A357   ; parse numeric expression into floating-point accumulator (FAC)
CHRGET = $A432   ; character fetch
WARMSTRT = $A491 ; warm start
PRNREADY = $A4D4 ; READY prompt
COLDSTRT = $A77F ; cold start
STMTDISP = $A86C ; statement dispatcher
PRINT = $A8C3    ; PRINT statement handler
PRNTCRLF = $A8E5 ; end-of-PRINT, newline handler
EVAL = $AC0C     ; expression evaluation
CLEAR = $B7E8    ; CLEAR statement handler
INPUT = $B96E    ; INPUT statement handler

; ram addresses
LOFROM = $FE      ; store 'current address' for most routines; 'from'
HIFROM = $FF      ; ... address in save, move and tabular display
LDFLAG = $0203    ; BASIC load flag: 00 - no load; FF - load from ACIA
CHROUTV = $021A   ; chr output vector (low)
CHROUTVH = $021B  ; chr output vector (high)
USERLO = $0233    ; location of start of  user routine called by
USERHI = $0234    ; machine code monitor's U command

; encoder
ENCODER = $8800   ; main ROM entry, prints "ENCODER D/A?"
CMDLOOP = $882B   ; wait for D/A/CR command
GOBASIC = $883A   ; JMP $0000 (warm start BASIC)
CHROUTH = $883D   ; chr output handler
DISCMD = $8844    ; handle 'D' command, enter disassembly mode
PROMPT = $884B    ; print assembler prompt and wait
DISPAGE = $8D5E   ; disassemble one page (15 instructions) from address
DISWAIT = $8D7E   ; wait for CR/LF/D during disassembly
DISNEXT = $8D70   ; start next instruction line
DISLOOP = $8D90   ; per-instruction disassembly loop (one page)
OPCDEC  = $8DA4   ; decode opcode, classify instruction
DISFMT = $8DDA    ; format & emit one disassembled instruction
PRNEXT = $8E66   ; compute and print next instruction address
PRADDR = $8E6F    ; print 16-bit address (A=hi, X=lo)
PRHEX = $8E73     ; print A as two hex digits
DISLINE = $8E7D   ; start new disassembly line (CRLF + print PC)
NEXTPC = $8E90    ; compute next instruction address
ASMCMD = $8849    ; handle 'A' command, prompt for M/L
ASMLOOP = $8850   ; wait for M, L, or CR after 'A'
GOMON = $885B     ; CR: enter monitor
ASMMEM = $885E    ; M: assemble source from BASIC program text
ASMTAPE = $8878   ; L: assemble source loaded from tape
INSCHOUT = $888A  ; install top-level CHROUT handler
PRNEXTPC = $8895  ; print PC + instruction length in hex
PRPCHEX = $889D   ; Print PC as hex (PCLO/PCHI)
PRPCHI = $88A4    ; print PCHI in hex and adjust opcode
PRHEXDEC = $88A6  ; Print hex byte, dec OPCODE if emitted
FINDLBL = $88AE   ; parse an identifier (label/symbol) from the source line and look it up in the symbol table
MODEEXIT = $8942  ; mode-dependent exit (ASM→BASIC, DIS→ENCODER)
OPRESOLV = $89D0  ; resolve operand expression
OPRCONT  = $89D1  ; continue operand resolution at current char
OPRSTART = $89D3  ; begin operand resolution with current char in A
OPRVALUE = $8A1B  ; resolve symbol value and apply instruction format
PRTPROM  = $8A72  ; print '?'-terminated prompt string
ASMCHOUT = $8A97  ; install assembler CHROUT handler
CALCPC   = $8AA2  ; calculate base PC from origin + offset
RESTREG = $8AD8   ; restore A/X/Y after ASMCOUTH hook
ASMCOUTH = $8ADF  ; assembler CHROUT handler
SKIPSPC = $8AB1   ; skip spaces and test for end
ASMTERM = $8B02   ; terminate assembly line buffer
ASMNEXT = $8B06   ; advance to next assembly line
ASMSKIP = $8B08   ; skip whitespace in line
EMITCHR = $8E3D   ; output character in A via OUTVEC
INSTSEP = $8E87   ; separator between mnemonic and operand
EMITSPC = $8E89   ; emit X spaces for column alignment

; tables
OPCLASS = $8E9F   ; opcode class table (indexed by reduced opcode bits)
OPINFO  = $8EE3   ; opcode info table: mnemonic + addressing-mode encoding
ADRPFX = $8EF0    ; addressing-mode prefix chars
ADRSFX = $8EF6    ; addressing-mode suffix chars
MNEMLEN = $8EFF   ; instruction mnemonic length table
MNEMTAB = $8F3F   ; packed mnemonic character data

; ram addresses used
SRCLINE  = $12    ; source line buffer (assembled input line)
WORKPTR2 = $DB    ; secondary workspace pointer (low)
WORKPT2H = $DC    ; secondary workspace pointer (high)
SAVEX    = $DD    ; saved X register (temporary)
SAVEY    = $DE    ; saved Y register (temporary)
SAVEA    = $DF    ; saved A register (temporary)
MODEFLG   = $E0   ; signed mode/state flag (asm vs disasm)
ASMIDX   = $E1    ; assembler output buffer index
WORKPTR = $E7     ; workspace pointer (low)
WORKPTRH = $E8    ; workspace pointer (high)
CMDDEPTH  = $F0   ; command nesting / reentry counter
OPCODE = $F1      ; decoded opcode / mnemonic selector
OPMODE = $F2      ; addressing mode / operand length
INSLEN = $F3      ; instruction length / operand byte count
INSFMT = $F4      ; instruction format / operand mask
PAGCNT = $F7      ; instruction counter per page (~15)
ABRTFLG = $F8     ; abort / formatting flag
PCLO    = $F9     ; current disassembly PC (low byte)
PCHI    = $FA     ; current disassembly PC (high byte)
